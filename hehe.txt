Collecting workspace information

Filtering to most relevant information

Models Folder - Complete Breakdown
Let me explain everything from scratch about your data models and how they work in your database system.

What are Models?
Models are data structures that represent real-world entities in your meeting system. Think of them as blueprints or templates for storing information about users, meetings, files, etc.

Each model has:

Data members (variables) - what information to store
Serialization/Deserialization - how to convert to/from bytes for disk storage
Size calculation - how much space it needs
1. User Model (src/models/User.h)
Variables and Their Purpose:
struct User {
    uint64_t user_id;          // Unique ID for each user (like a social security number)
    char email[128];           // User's email (max 128 characters)
    char password_hash[64];    // Encrypted password (NOT plain text!)
    char username[64];         // Display name
    uint64_t created_at;       // When account was created (Unix timestamp)
};
What each does:

user_id: Acts as a primary key in database terms. Every user gets a unique number.
email: Used for login, must be unique
password_hash: Stores the encrypted version of password (security!)
username: What other users see in meetings/chat
created_at: Timestamp in seconds since Jan 1, 1970 (standard Unix time)
Why uint64_t? It's an unsigned 64-bit integer (0 to 18 quintillion). Perfect for IDs and timestamps.

2. Meeting Model (src/models/Meeting.h)
Variables:
struct Meeting {
    uint64_t meeting_id;       // Unique ID for this meeting
    char meeting_code[16];     // Join code like "ABC-DEF-123"
    char title[128];           // Meeting name
    uint64_t creator_id;       // Which user created it
    uint64_t created_at;       // When it was created
    uint64_t started_at;       // When meeting actually started
    uint64_t ended_at;         // When it ended
    bool is_active;            // Is meeting currently running?
};
Significance:

meeting_code: Human-friendly way to join meetings
creator_id: Links to User (foreign key relationship)
started_at/ended_at: Track meeting lifecycle
is_active: Quick check if meeting is live
3. Message Model (src/models/Message.h)
Variables:

struct Message {
    uint64_t message_id;       // Unique message ID
    uint64_t meeting_id;       // Which meeting this is in
    uint64_t user_id;          // Who sent it
    char username[64];         // Sender's name (cached for speed)
    char content[512];         // The actual message text
    uint64_t timestamp;        // When it was sent
};
Why cache username?
Instead of looking up the user every time you display a message, you store the username directly. This is called denormalization - trading disk space for speed.

4. FileRecord Model (src/models/File.h)
Variables:
struct FileRecord {
    uint64_t file_id;          // Unique file ID
    uint64_t meeting_id;       // Which meeting it belongs to
    uint64_t uploader_id;      // Who uploaded it
    char filename[256];        // Original filename
    char file_hash[64];        // SHA-256 hash for deduplication
    uint64_t file_size;        // Size in bytes
    uint64_t uploaded_at;      // Upload timestamp
    uint64_t data_page_id;     // Where actual file data starts on disk
};
Key concepts:

file_hash: If two people upload the same file, you detect it and store only one copy (deduplication)
data_page_id: Files are stored across multiple pages (chunks). This points to the first page.
5. WhiteboardElement Model (src/models/WhiteboardElement.h)
Variables:
struct WhiteboardElement {
    uint64_t element_id;       // Unique element ID
    uint64_t meeting_id;       // Which meeting's whiteboard
    uint64_t user_id;          // Who drew it
    uint8_t element_type;      // 0=line, 1=rect, 2=circle, 3=text
    int16_t x1, y1, x2, y2;    // Coordinates (start and end points)
    uint8_t color_r, color_g, color_b;  // RGB color values
    uint16_t stroke_width;     // Thickness of line
    char text[256];            // Text content (for text elements)
    uint64_t timestamp;        // When it was drawn
};
Why these types?

uint8_t: 0-255, perfect for RGB colors
int16_t: -32,768 to 32,767, good for coordinates
uint16_t: 0-65,535, enough for stroke width
Understanding memset and memcpy
memset
memset(email, 0, sizeof(email));
What it does: Sets all bytes in email to 0 (zeros out the memory)

Why needed?

Prevents garbage data in unused parts of the array
When you write "bob@mail.com" in a 128-byte array, bytes 12-127 need to be zeroed
Security: old data in memory could leak sensitive info
Example:
char name[10];
strcpy(name, "Bob");  // Only uses 4 bytes (Bob + null terminator)
// Bytes 4-9 contain random garbage!

memset(name, 0, sizeof(name));  // Now all bytes are 0
strcpy(name, "Bob");  // Clean slate
memcpy
memcpy(buffer + offset, &user_id, sizeof(user_id));
What it does: Copies bytes from source to destination

Parameters:

destination: where to copy TO
source: where to copy FROM
size: how many bytes to copy
Why needed?
To convert structured data into a byte stream for storage.

Serialization and Deserialization
What is Serialization?
Converting a struct into bytes so you can:

Write it to disk
Send it over network
Store it in database pages
Example:
User user;
user.user_id = 123;
strcpy(user.email, "bob@mail.com");
// user is now in memory as a struct

uint8_t buffer[User::serialized_size()];
user.serialize(buffer);
// buffer now contains: [123 as 8 bytes][email as 128 bytes][password as 64 bytes]...
How serialize() Works:
void serialize(uint8_t* buffer) const {
    size_t offset = 0;
    memcpy(buffer + offset, &user_id, sizeof(user_id)); 
    offset += sizeof(user_id);
    memcpy(buffer + offset, email, sizeof(email)); 
    offset += sizeof(email);
    memcpy(buffer + offset, password_hash, sizeof(password_hash)); 
    offset += sizeof(password_hash);
    memcpy(buffer + offset, username, sizeof(username)); 
    offset += sizeof(username);
    memcpy(buffer + offset, &created_at, sizeof(created_at)); 
    offset += sizeof(created_at);
}
Step by step:

Start with offset = 0
Copy user_id (8 bytes) to buffer at position 0
Move offset to 8
Copy email (128 bytes) to buffer at position 8
Move offset to 136
Continue for all fields...
Result: A contiguous byte array like:

Deserialization
Converting bytes back into a struct:
void deserialize(const uint8_t* buffer) {
    size_t offset = 0;
    memcpy(&user_id, buffer + offset, sizeof(user_id)); 
    offset += sizeof(user_id);
    memcpy(email, buffer + offset, sizeof(email)); 
    offset += sizeof(email);
    // ... continues
}

Does the reverse:

Read 8 bytes from buffer → user_id
Read next 128 bytes → email
And so on...
Why is This Needed?
1. Database Storage
Your database stores everything as 4KB pages (src/storage/Page.h):
class Page {
    uint8_t data[PAGE_DATA_SIZE];  // 4096 bytes
};
To store a User in a page:
User user;
// ... fill user data ...
uint8_t buffer[User::serialized_size()];
user.serialize(buffer);  // Convert to bytes

Page page;
memcpy(page.data, buffer, User::serialized_size());  // Write to page
db.write_page(page_id, page);  // Save to disk

2. Reading from Database
Page page = db.read_page(page_id);  // Read from disk
User user;
user.deserialize(page.data);  // Convert bytes back to struct
// Now you can use user.email, user.username, etc.
3. Fixed Size = Fast Indexing
static size_t serialized_size() {
    return sizeof(user_id) + sizeof(email) + sizeof(password_hash) + 
           sizeof(username) + sizeof(created_at);
}
Why fixed size?

If User is always 272 bytes, you can calculate positions mathematically
1st user at byte 0, 2nd at byte 272, 3rd at byte 544...
No need to search - instant lookup!
Real Usage Example
Storing a User (from src/managers/AuthManager.cpp):
bool AuthManager::store_user(const User& user) {
    // 1. Get a page from database
    uint64_t data_page_id = db->allocate_page();
    
    // 2. Serialize user to bytes
    uint8_t buffer[User::serialized_size()];
    user.serialize(buffer);
    
    // 3. Copy bytes to page
    Page data_page;
    memcpy(data_page.data, buffer, User::serialized_size());
    
    // 4. Write page to disk
    db->write_page(data_page_id, data_page);
    
    // 5. Create index entry (for fast lookup)
    RecordLocation user_loc(data_page_id, 0, User::serialized_size());
    users_btree->insert(user.user_id, user_loc);
    login_hash->insert(user.email, user_loc);
    
    return true;
}
Retrieving a User (from src/managers/AuthManager.cpp):
bool AuthManager::get_user_by_id(uint64_t user_id, User& out_user) {
    // 1. Find page location using B-Tree
    bool found;
    RecordLocation loc = users_btree->search(user_id, found);
    if (!found) return false;
    
    // 2. Read page from disk
    Page page = db->read_page(loc.page_id);
    
    // 3. Deserialize bytes to User struct
    out_user.deserialize(page.data + loc.offset);
    
    return true;
}
Summary
Models:
User: Who can login and join meetings
Meeting: A video call session
Message: Chat messages in meetings
FileRecord: Files uploaded to meetings
WhiteboardElement: Drawings on whiteboard
memset:
Zeros out memory to prevent garbage data

memcpy:
Copies bytes from one place to another

Serialization:
Struct → Bytes (for storage)

Deserialization:
Bytes → Struct (for use)

Why all this?
Because computers only understand bytes. You need to convert your nice structs into raw bytes to store them on disk, then convert back when you need them.

Key Takeaway: Your models are like forms. Serialization is photocopying them into a filing cabinet (disk). Deserialization is taking the photocopy and reconstructing the original form to work with.

Claude Sonnet 4.5 • 1x